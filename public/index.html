<!DOCTYPE html>
<html lang="ht">
<head>
  <meta charset="UTF-8"/>
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"/>
  <title>Adam_D'H7</title>
  <link rel="manifest" href="manifest.json" />
  <link rel="icon" type="image/jpeg" href="https://res.cloudinary.com/dglludnfq/image/upload/v1759278052/tf-stream-url/Screenshot_20250930_202003_Gallery.jpg" />
  <link rel="apple-touch-icon" href="https://res.cloudinary.com/dglludnfq/image/upload/v1759278052/tf-stream-url/Screenshot_20250930_202003_Gallery.jpg" />
  <meta name="apple-mobile-web-app-capable" content="yes" />
  <meta name="mobile-web-app-capable" content="yes" />
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent" />
  <link href="https://fonts.googleapis.com/css2?family=Roboto:wght@400;700&display=swap" rel="stylesheet" />
  <style>
    :root{
      --bg: #000000;
      --panel: #000000;
      --name-gray: #7d7d7d;
      --ai-bubble: #262626;
      --ai-text: #d0d0d0;
      --user-blue: #0b3d91;
      --user-text: #e8f4ff;
      --border: rgba(255,255,255,0.04);
      --timestamp: #6faee6;
      --header-h: 56px;
      --form-h: 84px;
    }
    html,body{
      height:100%;
      margin:0;
      padding:0;
      background:var(--bg);
      color:var(--ai-text);
      font-family:Arial,Helvetica,sans-serif;
      -webkit-text-size-adjust:100%;
      -webkit-overflow-scrolling:touch;
      overscroll-behavior-y:none;
      overflow:hidden;
      touch-action:pan-y;
    }
    header{
      background:var(--panel);
      height:var(--header-h);
      display:flex;
      align-items:center;
      justify-content:center;
      position:fixed;
      top:0;
      left:0;
      right:0;
      z-index:999;
      box-shadow:0 1px 0 rgba(255,255,255,0.02) inset;
      padding:0 12px;
      user-select:none;
    }
    .menu-btn{position:absolute;left:12px;font-size:22px;cursor:pointer;color:var(--ai-text)}
    .name-title{font-weight:800;color:var(--name-gray);font-size:20px;letter-spacing:0.2px;white-space:nowrap;overflow:hidden;text-overflow:ellipsis}
    .chat-box{
      position:fixed;
      left:0;
      right:0;
      top:var(--header-h);
      bottom:var(--form-h);
      display:flex;
      flex-direction:column;
      padding:12px 18px;
      padding-top: 12px;
      padding-bottom: 12px;
      overflow-y:auto;
      background:var(--panel);
      box-sizing:border-box;
      -webkit-overflow-scrolling:touch;
    }
    .message{margin:12px 0;max-width:72%;position:relative;overflow-wrap:anywhere;word-break:break-word;white-space:pre-wrap}
    .message.user{align-self:flex-end}
    .message.bot{align-self:flex-start}
    .message.user .content{background:var(--user-blue);color:var(--user-text);border-radius:18px;padding:10px 14px}
    .message.bot .content{background:var(--ai-bubble);color:var(--ai-text);border-radius:18px;padding:10px 14px;border:1px solid var(--border)}
    .content{font-size:15px;line-height:1.35}
    .timestamp{font-size:11px;color:var(--timestamp);margin-top:6px;text-align:right}
    .message.bot.thinking .content{display:flex;align-items:center;justify-content:flex-start;gap:10px;background:var(--ai-bubble);padding:8px 12px}
    .thinking-dots{display:inline-flex;gap:8px}
    .thinking-dots span{
      display:inline-block;width:9px;height:9px;border-radius:50%;background:var(--timestamp);opacity:0.12;transform:translateY(0);animation:dot 1.6s infinite ease-in-out;
    }
    .thinking-dots span:nth-child(1){ animation-delay:0s; }
    .thinking-dots span:nth-child(2){ animation-delay:0.45s; }
    .thinking-dots span:nth-child(3){ animation-delay:0.9s; }
    @keyframes dot{
      0% {opacity:0.12; transform:translateY(0);}
      25% {opacity:0.9; transform:translateY(-7px);}
      55% {opacity:0.35; transform:translateY(0);}
      100% {opacity:0.12; transform:translateY(0);}
    }
    .sidebar{position:fixed;top:0;left:-100%;width:80%;height:100%;background:var(--panel);z-index:1001;box-shadow:2px 0 12px rgba(0,0,0,0.7);transition:left .28s ease;padding:18px;color:var(--ai-text);box-sizing:border-box}
    .sidebar.active{left:0}
    .menu-header{display:flex;justify-content:space-between;align-items:center;margin-bottom:12px}
    .chat-list{list-style:none;padding:0;margin:0;overflow-y:auto;max-height:calc(100% - 60px)}
    .chat-list li{padding:8px;border-radius:6px;cursor:pointer;transition:background .18s;margin-bottom:10px;color:var(--ai-text)}
    .chat-list li:hover{background:rgba(255,255,255,0.02)}
    .sidebar .new-chat-btn{background:none;border:1px solid rgba(255,255,255,0.06);color:var(--ai-text);padding:6px 10px;border-radius:8px;cursor:pointer;font-size:14px}
    .code-modal{background:#000;color:var(--ai-text);font-family:Menlo,monospace;padding:18px;border-radius:10px;margin:14px 0;max-width:90%;white-space:pre-wrap;border:1px solid rgba(255,255,255,0.03)}
    .copy-btn{position:absolute;top:10px;right:10px;background:var(--user-blue);color:var(--user-text);border:none;border-radius:6px;padding:6px 10px;cursor:pointer}
    form{display:flex;padding:12px;background:var(--panel);border-top:1px solid rgba(255,255,255,0.03);position:fixed;bottom:0;left:0;right:0;align-items:center;gap:10px;height:var(--form-h);box-sizing:border-box}
    textarea{flex:1;padding:10px;font-size:15px;border-radius:18px;border:1px solid rgba(255,255,255,0.04);outline:none;resize:none;height:56px;background:#050505;color:var(--ai-text);box-sizing:border-box;width:100%}
    textarea::placeholder{color:rgba(255,255,255,0.18)}
    .send{
      display:inline-flex;
      align-items:center;
      justify-content:center;
      width:48px;
      height:48px;
      background:linear-gradient(180deg,var(--user-blue),#06306a);
      border-radius:50%;
      border:none;
      padding:0;
      cursor:pointer;
      box-shadow:0 6px 18px rgba(11,61,145,0.14);
    }
    .send[disabled]{ opacity:0.5; cursor:default; pointer-events:none; }
    .send svg{ width:20px; height:20px; display:block; filter:invert(1) contrast(200%); }
    @media (max-width:600px){
      .chat-box{padding:12px;padding-top: calc(var(--header-h) + 8px);padding-bottom: calc(var(--form-h) + 8px)}
      header{font-size:18px}
    }
  </style>
</head>
<body>
  <header>
    <div class="menu-btn" onclick="toggleSidebar()" aria-label="menu">☰</div>
    <div class="name-title" id="headerName">Adam_D'H7</div>
  </header>

  <div class="sidebar" id="sidebar" aria-hidden="true">
    <div class="menu-header">
      <h3 style="margin:0;color:var(--ai-text)">Chats</h3>
      <button class="new-chat-btn" onclick="newChat()">Nouveau Chat</button>
    </div>
    <ul class="chat-list" id="chatList"></ul>
  </div>

  <div class="chat-box" id="chatBox" tabindex="-1" aria-live="polite"></div>

  <form id="chatForm" autocomplete="off" novalidate>
    <textarea id="userInput" placeholder="Adam_D'H7 le meilleure assistant" aria-label="Message"></textarea>
    <button id="sendBtn" class="send" type="submit" aria-label="Send">
      <svg viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false">
        <path d="M2 21L23 12L2 3L8 12L2 21Z" fill="currentColor"/>
      </svg>
    </button>
  </form>

  <script>
    // -------- layout helpers --------
    const headerEl = document.querySelector('header');
    const chatBox = document.getElementById('chatBox');
    const formEl = document.querySelector('form');
    const textarea = document.getElementById('userInput');
    const sendBtn = document.getElementById('sendBtn');

    function scrollToBottom(immediate = true) {
      try {
        if (immediate) chatBox.scrollTop = chatBox.scrollHeight;
        else chatBox.scrollTo({ top: chatBox.scrollHeight, behavior: 'smooth' });
      } catch (e) {}
    }

    function adjustLayoutForViewport() {
      const headerH = headerEl.offsetHeight || 56;
      const formH = formEl.offsetHeight || 84;
      chatBox.style.top = headerH + 'px';
      chatBox.style.bottom = formH + 'px';
      chatBox.style.paddingTop = '12px';
      setTimeout(()=> scrollToBottom(true), 60);
    }

    window.addEventListener('load', ()=>{ adjustLayoutForViewport(); });
    window.addEventListener('resize', ()=>{ adjustLayoutForViewport(); });

    textarea.addEventListener('focus', ()=>{ setTimeout(()=> adjustLayoutForViewport(), 80); setTimeout(()=> scrollToBottom(true), 150); });
    textarea.addEventListener('blur', ()=>{ setTimeout(()=> adjustLayoutForViewport(), 80); });
    textarea.addEventListener('input', ()=>{ scrollToBottom(true); });

    window.addEventListener('gesturestart', e => e.preventDefault());

    // -------- session & UI state (local) --------
    if(!document.getElementById('headerName').textContent.trim()) document.getElementById('headerName').textContent = "Adam_D'H7";
    if (Notification && Notification.permission !== 'granted') Notification.requestPermission();

    const STORAGE_KEY = 'tfai_sessions';
    let sessions = JSON.parse(localStorage.getItem(STORAGE_KEY) || '[]');
    let currentSession = sessions.length ? 0 : null;

    function save(){ localStorage.setItem(STORAGE_KEY, JSON.stringify(sessions)); }

    function toggleSidebar(){
      const sb = document.getElementById('sidebar');
      sb.classList.toggle('active');
      sb.setAttribute('aria-hidden', !sb.classList.contains('active'));
    }

    function newChat(){
      sessions.unshift({ title: "Nouveau Chat", messages: [] });
      currentSession = 0;
      save(); renderList(); renderBox();
      const sb = document.getElementById('sidebar'); if(!sb.classList.contains('active')) sb.classList.add('active');
    }

    function renderList(){
      const l = document.getElementById('chatList'); l.innerHTML = '';
      sessions.forEach((s,i)=>{
        const li = document.createElement('li'); li.textContent = s.title || 'Chat'; li.onclick = ()=>{ currentSession = i; renderBox(); toggleSidebar(); }; l.appendChild(li);
      });
    }

    function renderBox(){
      chatBox.innerHTML = '';
      if (currentSession === null) {
        chatBox.innerHTML = '<div style="padding:20px;color:var(--ai-text)">Aucun chat — ouvri sidebar epi klike Nouveau Chat pou kòmanse</div>';
        return;
      }
      const sess = sessions[currentSession];
      sess.messages.forEach(m => {
        const wrap = document.createElement('div');
        if (m.sender === 'thinking') {
          wrap.className = 'message bot thinking';
          const content = document.createElement('div'); content.className = 'content';
          content.innerHTML = '<div class="thinking-dots"><span></span><span></span><span></span></div>';
          wrap.appendChild(content);
        } else {
          wrap.className = 'message ' + (m.sender === 'user' ? 'user' : 'bot');
          if (typeof m.text === 'string' && m.text.startsWith('```') && m.text.endsWith('```')) {
            const content = m.text.slice(3,-3);
            const modal = document.createElement('div'); modal.className = 'code-modal'; modal.textContent = content;
            const btn = document.createElement('button'); btn.className = 'copy-btn'; btn.textContent = 'Copy';
            btn.onclick = ()=>{ navigator.clipboard.writeText(content); btn.textContent='✔️'; setTimeout(()=>btn.textContent='Copy',1000); };
            modal.appendChild(btn); wrap.appendChild(modal);
          } else {
            const c = document.createElement('div'); c.className = 'content'; c.textContent = m.text; wrap.appendChild(c);
            if (m.sender === 'bot' && m.ts) {
              const ts = document.createElement('div'); ts.className = 'timestamp';
              const diff = Math.floor((Date.now() - m.ts) / 1000);
              ts.textContent = diff < 60 ? `${diff}s` : `${Math.floor(diff/60)}m`;
              wrap.appendChild(ts);
            }
          }
        }
        chatBox.appendChild(wrap);
      });
      scrollToBottom();
    }

    // -------- paste behavior (submit after paste) --------
    const chatForm = document.getElementById('chatForm');
    textarea.addEventListener('paste', (e)=>{
      setTimeout(()=> {
        const val = textarea.value;
        if (!val || !val.trim()) return;
        if (typeof chatForm.requestSubmit === 'function') chatForm.requestSubmit();
        else chatForm.dispatchEvent(new Event('submit', { cancelable: true }));
      }, 20);
    });

    // -------- robust extract helper --------
    function collectStrings(value) {
      if (value == null) return '';
      if (typeof value === 'string') return value;
      if (typeof value === 'number' || typeof value === 'boolean') return String(value);
      if (Array.isArray(value)) return value.map(v => collectStrings(v)).join('');
      if (typeof value === 'object') {
        let out = '';
        for (const k of Object.keys(value)) out += collectStrings(value[k]);
        return out;
      }
      return '';
    }
    function extractAssistantTextFromResp(j) {
      if (!j) return null;
      if (Array.isArray(j.choices) && j.choices.length) {
        const c = j.choices[0];
        if (c.message && typeof c.message.content === 'string' && c.message.content.trim()) return c.message.content.trim();
        if (c.message && c.message.content) {
          const s = collectStrings(c.message.content).trim();
          if (s) return s;
        }
        if (typeof c.text === 'string' && c.text.trim()) return c.text.trim();
        if (c.delta) {
          const s3 = collectStrings(c.delta).trim();
          if (s3) return s3;
        }
        try { return JSON.stringify(c).slice(0, 2000); } catch (e) { return null; }
      }
      if (typeof j.assistant === 'string' && j.assistant.trim()) return j.assistant.trim();
      if (typeof j.text === 'string' && j.text.trim()) return j.text.trim();
      const fallback = collectStrings(j).trim();
      if (fallback) return fallback;
      return null;
    }

    // -------- remove timestamps helper --------
    function removeAllTimestamps() {
      const ts = chatBox.querySelectorAll('.timestamp');
      ts.forEach(el => el.remove());
    }

    // -------- prevent duplicate sends: inFlight flag + clientMsgId --------
    let inFlight = false; // single inflight per client
    function genClientMsgId() {
      if (typeof crypto !== 'undefined' && crypto.randomUUID) return crypto.randomUUID();
      return Date.now().toString(36) + '-' + Math.random().toString(36).slice(2,9);
    }

    // -------- submit flow --------
    chatForm.addEventListener('submit', async (e)=>{
      e.preventDefault();
      const raw = textarea.value;
      const text = (typeof raw === 'string') ? raw.trim() : '';
      if (!text) return;

      // prevent double send
      if (inFlight) {
        console.log('Send already in progress — ignoring duplicate submit');
        return;
      }
      inFlight = true;
      sendBtn.disabled = true;

      // remove timestamps (as requested)
      removeAllTimestamps();

      if (currentSession === null) newChat();
      const sess = sessions[currentSession];

      // push user locally
      const userMessage = { sender: 'user', text, ts: Date.now() };
      sess.messages.push(userMessage);
      if (sess.messages[0] && typeof sess.messages[0].text === 'string') sess.title = sess.messages[0].text.slice(0,100);
      save(); renderList(); renderBox();

      // clear input so user can continue typing/pasting
      textarea.value = '';
      textarea.focus();

      // add thinking bubble
      const thinking = { sender: 'thinking', ts: Date.now() };
      sess.messages.push(thinking); save(); renderBox();

      // create clientMsgId for idempotency
      const clientMsgId = genClientMsgId();

      let assistantAdded = false;
      const abortController = new AbortController();
      const TIMEOUT_MS = 30_000; // 30s timeout
      const timeoutId = setTimeout(()=> abortController.abort(), TIMEOUT_MS);

      try {
        // ensure user exists
        let tfid = localStorage.getItem('tfid');
        if (!tfid) {
          const ru = await fetch('/user', { method: 'POST', headers: {'Content-Type':'application/json'}, body: JSON.stringify({}) });
          if (!ru.ok) throw new Error('/user failed ' + ru.status);
          const ju = await ru.json(); tfid = ju.tfid; localStorage.setItem('tfid', tfid);
        }

        // ensure session exists
        let sessionId = localStorage.getItem('currentSessionId');
        if (!sessionId) {
          const rs = await fetch('/session', { method: 'POST', headers: {'Content-Type':'application/json'}, body: JSON.stringify({ tfid }) });
          if (!rs.ok) throw new Error('/session failed ' + rs.status);
          const js = await rs.json(); sessionId = js.sessionId; localStorage.setItem('currentSessionId', sessionId);
        }

        // make fetch with clientMsgId and abort support
        const r = await fetch('/message', {
          method: 'POST',
          headers: {'Content-Type':'application/json'},
          body: JSON.stringify({ tfid: localStorage.getItem('tfid'), sessionId: localStorage.getItem('currentSessionId'), text, clientMsgId }),
          signal: abortController.signal
        });

        clearTimeout(timeoutId);

        if (!r.ok) {
          const txt = await r.text().catch(()=>null);
          console.warn('/message returned not ok', r.status, txt && txt.slice ? txt.slice(0,200) : txt);
          throw new Error('/message fail ' + r.status);
        }

        const jr = await r.json();

        // remove thinking bubble locally
        const idx = sess.messages.indexOf(thinking); if (idx > -1) sess.messages.splice(idx, 1);

        // extract assistant text robustly
        let assistantText = null;
        if (jr && typeof jr.assistant === 'string' && jr.assistant.trim()) assistantText = jr.assistant.trim();
        if (!assistantText && jr && jr.raw) assistantText = extractAssistantTextFromResp(jr.raw);
        if (!assistantText && jr) assistantText = extractAssistantTextFromResp(jr);

        if (!assistantText || !assistantText.trim()) assistantText = '(Repons pa klè)';

        sess.messages.push({ sender: 'bot', text: assistantText, ts: Date.now() });
        assistantAdded = true;
        save(); renderBox();

        if (document.hidden && Notification.permission === 'granted') new Notification('TF-Chat', { body: 'Nouvo mesaj TF-Chat' });

      } catch (err) {
        console.warn('Error sending message or parsing response:', err && err.message ? err.message : err);
        // remove thinking bubble if present
        try { const idx2 = sess.messages.findIndex(m => m.sender === 'thinking'); if (idx2 !== -1) sess.messages.splice(idx2, 1); } catch(e){}
        // Add fallback assistant note if nothing else
        const lastBot = [...sess.messages].reverse().find(m => m.sender === 'bot');
        if (!lastBot) {
          sess.messages.push({ sender: 'bot', text: 'Repons la vini. (egzanp)', ts: Date.now() });
        }
        save(); renderBox();
      } finally {
        clearTimeout(timeoutId);
        inFlight = false;
        sendBtn.disabled = false;
        // ensure thinking removed
        try {
          const idx2 = sess.messages.findIndex(m => m.sender === 'thinking');
          if (idx2 !== -1) sess.messages.splice(idx2, 1);
        } catch(e){}
        // ensure there's at least a bot reply
        const lastBot = [...sess.messages].reverse().find(m => m.sender === 'bot');
        if (!lastBot) {
          sess.messages.push({ sender: 'bot', text: 'Repons la vini. (egzanp)', ts: Date.now() });
        }
        save(); renderBox();
      }
    });

    // Enter = send (no Shift). Shift+Enter = newline
    textarea.addEventListener('keydown', (e)=>{
      if (e.key === 'Enter' && !e.shiftKey) {
        e.preventDefault();
        // submit form programmatically
        if (typeof chatForm.requestSubmit === 'function') chatForm.requestSubmit();
        else chatForm.dispatchEvent(new Event('submit', { cancelable: true }));
      }
    });

    // initial render
    if (sessions.length) renderList(), renderBox();
    adjustLayoutForViewport();

    // service worker registration (unchanged)
    window.addEventListener('load', () => {
      if ('serviceWorker' in navigator) {
        navigator.serviceWorker.register('/sw.js', { scope: '/' })
          .then(reg => {
            navigator.serviceWorker.ready.then(regReady => {
              if (regReady.active && regReady.active.postMessage) {
                regReady.active.postMessage({ type: 'LIST_CACHES' });
              }
            });
          })
          .catch(()=>{/* silent */});
        navigator.serviceWorker.addEventListener('message', ()=>{/* silent */});
      }
    });
  </script>
</body>
    </html>
