<!DOCTYPE html>
<html lang="ht">
<head>
  <meta charset="UTF-8"/>
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"/>
  <title>Adam_D'H7</title>
  <link rel="manifest" href="manifest.json" />
  <link rel="icon" type="image/jpeg" href="https://res.cloudinary.com/dglludnfq/image/upload/v1759692398/tf-stream-url/IMG-20251002-WA0108.jpg" />
  <link rel="apple-touch-icon" href="https://res.cloudinary.com/dglludnfq/image/upload/v1759692398/tf-stream-url/IMG-20251002-WA0108.jpg" />
  <meta name="apple-mobile-web-app-capable" content="yes" />
  <meta name="mobile-web-app-capable" content="yes" />
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent" />
  <link href="https://fonts.googleapis.com/css2?family=Roboto:wght@400;700&display=swap" rel="stylesheet" />
  <style>
    :root{
      --bg: #000000;
      --panel: #000000;
      --name-gray: #7d7d7d;
      --ai-bubble: #262626;
      --ai-text: #d0d0d0;
      --user-blue: #0b3d91;
      --user-text: #e8f4ff;
      --border: rgba(255,255,255,0.04);
      --timestamp: #6faee6;
      --header-h: 56px;
      --form-h: 84px;
    }

    html,body{
      height:100%; margin:0; padding:0; background:var(--bg); color:var(--ai-text);
      font-family:Roboto, Arial, Helvetica, sans-serif; -webkit-text-size-adjust:100%;
      -webkit-overflow-scrolling:touch; overscroll-behavior-y:none; overflow:hidden; touch-action:pan-y;
    }

    header{
      background:var(--panel); height:var(--header-h); display:flex; align-items:center; justify-content:center;
      position:fixed; top:0; left:0; right:0; z-index:999; padding:0 12px; user-select:none;
      box-shadow:0 1px 0 rgba(255,255,255,0.02) inset;
      transition: top 120ms ease;
    }
    .menu-btn{position:absolute;left:12px;font-size:22px;cursor:pointer;color:var(--ai-text)}
    .name-title{font-weight:800;color:var(--name-gray);font-size:20px;letter-spacing:0.2px;white-space:nowrap;overflow:hidden;text-overflow:ellipsis}

    .chat-box{
      position:fixed; left:0; right:0; top:var(--header-h); bottom:var(--form-h);
      display:flex; flex-direction:column; padding:12px 18px; overflow-y:auto; background:var(--panel);
      box-sizing:border-box; -webkit-overflow-scrolling:touch;
      /* hide scrollbar visually but keep scrolling functionality */
      scrollbar-width: none; -ms-overflow-style: none;
    }
    .chat-box::-webkit-scrollbar { display: none; width:0; height:0; }

    /* Reduced spacing to avoid extra "enter" lines */
    .message{ margin:6px 0; max-width:76%; position:relative; overflow-wrap:anywhere; word-break:break-word; white-space:pre-wrap; }
    .message.user{ align-self:flex-end }
    .message.bot{ align-self:flex-start }
    .message.user .content{ background:var(--user-blue); color:var(--user-text); border-radius:18px; padding:10px 14px; }
    .message.bot .content{ background:var(--ai-bubble); color:var(--ai-text); border-radius:18px; padding:10px 14px; border:1px solid var(--border); }
    .content{ font-size:15px; line-height:1.35; margin:0; padding:0; } /* remove extra gap */
    .timestamp{ font-size:11px; color:var(--timestamp); margin-top:6px; text-align:right }

    .message.bot.thinking .content{ display:flex; align-items:center; justify-content:flex-start; gap:10px; background:var(--ai-bubble); padding:8px 12px }
    .thinking-dots{ display:inline-flex; gap:8px }
    .thinking-dots span{ display:inline-block; width:9px; height:9px; border-radius:50%; background:var(--timestamp); opacity:0.12; transform:translateY(0); animation:dot 1.6s infinite ease-in-out; }
    .thinking-dots span:nth-child(1){ animation-delay:0s; } .thinking-dots span:nth-child(2){ animation-delay:0.45s; } .thinking-dots span:nth-child(3){ animation-delay:0.9s; }
    @keyframes dot{ 0% {opacity:0.12; transform:translateY(0);} 25% {opacity:0.9; transform:translateY(-7px);} 55% {opacity:0.35; transform:translateY(0);} 100% {opacity:0.12; transform:translateY(0);} }

    .sidebar{ position:fixed; top:0; left:-100%; width:80%; height:100%; background:var(--panel); z-index:1001; box-shadow:2px 0 12px rgba(0,0,0,0.7); transition:left .28s ease; padding:18px; color:var(--ai-text); box-sizing:border-box }
    .sidebar.active{ left:0 }

    /* menu header layout adjusted to place center element exactly between left and right */
    .menu-header{ display:flex; justify-content:space-between; align-items:center; margin-bottom:12px; position:relative; }
    .menu-header h3{ margin:0; color:var(--ai-text) }

    .menu-center{
      position:absolute;
      left:50%;
      transform:translateX(-50%);
      display:flex;
      align-items:center;
      gap:8px;
      pointer-events:auto;
    }
    .erase-btn{
      background:none;
      border:1px solid rgba(255,255,255,0.06);
      color:var(--ai-text);
      padding:6px 10px;
      border-radius:8px;
      cursor:pointer;
      font-size:14px;
    }
    .erase-btn:hover{ background: rgba(255,255,255,0.02); }

    .chat-list{ list-style:none; padding:0; margin:0; overflow-y:auto; max-height:calc(100% - 60px) }
    .chat-list li{ padding:8px; border-radius:6px; cursor:pointer; transition:background .18s; margin-bottom:10px; color:var(--ai-text) }
    .chat-list li:hover{ background:rgba(255,255,255,0.02) }
    .sidebar .new-chat-btn{ background:none; border:1px solid rgba(255,255,255,0.06); color:var(--ai-text); padding:6px 10px; border-radius:8px; cursor:pointer; font-size:14px }

    /* Code card style (APK-like) - reduced spacing */
    .code-card{
      background:transparent;
      border-radius:12px;
      overflow:hidden;
      margin:4px 0; /* small margin so no extra enter appears */
      max-width:100%;
      box-shadow: 0 8px 20px rgba(0,0,0,0.4);
      border:1px solid rgba(255,255,255,0.03);
    }
    .code-header{
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:12px;
      padding:8px 10px;
      background: linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01));
      border-bottom:1px solid rgba(255,255,255,0.02);
      font-size:13px;
      color:var(--ai-text);
    }
    .code-header .label{ display:flex; align-items:center; gap:8px; font-weight:600; color:var(--ai-text); cursor:pointer; }
    .code-body{
      background:#060606;
      padding:8px 12px;
      font-family: Menlo, Monaco, "Courier New", monospace;
      font-size:13px;
      color:#dfe7f5;
      white-space:pre-wrap;
      line-height:1.45;
      margin:0;
    }

    .code-copy-btn{
      background:transparent;
      border: none;
      color:var(--ai-text);
      cursor:pointer;
      display:inline-flex;
      align-items:center;
      justify-content:center;
      padding:6px;
      gap:8px;
      border-radius:8px;
      transition:background .12s ease;
    }
    .code-copy-btn:hover{ background: rgba(255,255,255,0.02); }
    .code-copy-icon{ width:18px; height:18px; display:inline-block; }

    .code-header .right{ display:flex; align-items:center; gap:8px; }

    form{ display:flex; padding:12px; background:var(--panel); border-top:1px solid rgba(255,255,255,0.03); position:fixed; bottom:0; left:0; right:0; align-items:center; gap:10px; height:var(--form-h); box-sizing:border-box }
    textarea{ flex:1; padding:10px; font-size:15px; border-radius:18px; border:1px solid rgba(255,255,255,0.04); outline:none; resize:none; height:56px; background:#050505; color:var(--ai-text); box-sizing:border-box; width:100% }
    textarea::placeholder{ color:rgba(255,255,255,0.18) }
    .send{ display:inline-flex; align-items:center; justify-content:center; width:48px; height:48px; background:linear-gradient(180deg,var(--user-blue),#06306a); border-radius:50%; border:none; padding:0; cursor:pointer; box-shadow:0 6px 18px rgba(11,61,145,0.14); }
    .send svg{ width:20px; height:20px; display:block; filter:invert(1) contrast(200%); }

    @media (max-width:600px){
      .chat-box{ padding:12px; padding-top: calc(var(--header-h) + 8px); padding-bottom: calc(var(--form-h) + 8px) }
      header{ font-size:18px }
    }

    /* small helper for "scroll to bottom" badge (optional) */
    .scroll-bottom-badge{
      position:fixed; right:16px; bottom:calc(var(--form-h) + 16px); z-index:900;
      background:rgba(7,26,51,0.9); color:#fff; padding:8px 10px; border-radius:20px; cursor:pointer; display:none;
      font-size:13px;
    }
    .scroll-bottom-badge.show{ display:block; }
  </style>
</head>
<body>
  <header>
    <div class="menu-btn" onclick="toggleSidebar()" aria-label="menu">☰</div>
    <div class="name-title" id="headerName">Adam_D'H7</div>
  </header>

  <div class="sidebar" id="sidebar" aria-hidden="true">
    <div class="menu-header">
      <h3 style="margin:0;color:var(--ai-text)">Chats</h3>

      <!-- centered Efase tout -->
      <div class="menu-center" aria-hidden="false">
        <button class="erase-btn" onclick="eraseAll()" title="Effacer toutes les conversations et rafraîchir">Efase tout</button>
      </div>

      <button class="new-chat-btn" onclick="newChat()">Nouveau Chat</button>
    </div>
    <ul class="chat-list" id="chatList"></ul>
  </div>

  <div class="chat-box" id="chatBox" tabindex="0" aria-live="polite"></div>

  <div class="scroll-bottom-badge" id="scrollBadge" title="Aller au bas">Aller au bas</div>

  <form id="chatForm" autocomplete="off" novalidate>
    <textarea id="userInput" placeholder="Adam_D'H7 le meilleure assistant" aria-label="Message"></textarea>
    <button class="send" type="submit" aria-label="Send">
      <svg viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false">
        <path d="M2 21L23 12L2 3L8 12L2 21Z" fill="currentColor"/>
      </svg>
    </button>
  </form>

  <script>
    // Helpers + layout
    const headerEl = document.querySelector('header');
    const headerNameEl = document.getElementById('headerName');
    const chatBox = document.getElementById('chatBox');
    const formEl = document.querySelector('form');
    const textarea = document.getElementById('userInput');
    const chatForm = document.getElementById('chatForm');
    const scrollBadge = document.getElementById('scrollBadge');

    function scrollToBottom(immediate = true) {
      try {
        if (immediate) chatBox.scrollTop = chatBox.scrollHeight;
        else chatBox.scrollTo({ top: chatBox.scrollHeight, behavior: 'smooth' });
      } catch (e) {}
    }

    function adjustLayoutForViewport() {
      const headerH = headerEl.offsetHeight || 56;
      const formH = formEl.offsetHeight || 84;
      chatBox.style.top = headerH + 'px';
      chatBox.style.bottom = formH + 'px';
      chatBox.style.paddingTop = '12px';
      setTimeout(()=> {
        if (!userIsScrolling) scrollToBottom(true);
      }, 60);
    }

    window.addEventListener('load', ()=>{ adjustLayoutForViewport(); });
    window.addEventListener('resize', ()=>{ adjustLayoutForViewport(); });

    textarea.addEventListener('focus', ()=>{
      setTimeout(()=> adjustLayoutForViewport(), 80);
      setTimeout(()=> { if (!userIsScrolling) scrollToBottom(true); }, 150);
      // keep header visible on mobile keyboards via visualViewport handler (below)
    });
    textarea.addEventListener('blur', ()=>{ setTimeout(()=> adjustLayoutForViewport(), 80); });
    textarea.addEventListener('input', ()=>{ if (!userIsScrolling) scrollToBottom(true); });

    window.addEventListener('gesturestart', e => e.preventDefault());

    if(!headerNameEl.textContent.trim()) headerNameEl.textContent = "Adam_D'H7";
    if (typeof Notification !== 'undefined' && Notification && Notification.permission !== 'granted') Notification.requestPermission();

    const STORAGE_KEY = 'tfai_sessions';
    let sessions = JSON.parse(localStorage.getItem(STORAGE_KEY) || '[]');
    let currentSession = sessions.length ? 0 : null;
    function save(){ localStorage.setItem(STORAGE_KEY, JSON.stringify(sessions)); }

    function toggleSidebar(){
      const sb = document.getElementById('sidebar');
      sb.classList.toggle('active');
      sb.setAttribute('aria-hidden', !sb.classList.contains('active'));
    }

    function newChat(){
      sessions.unshift({ title: "Nouveau Chat", messages: [] });
      currentSession = 0;
      save(); renderList(); renderBox();
      const sb = document.getElementById('sidebar'); if(!sb.classList.contains('active')) sb.classList.add('active');
    }

    function renderList(){
      const l = document.getElementById('chatList'); l.innerHTML = '';
      sessions.forEach((s,i)=>{
        const li = document.createElement('li'); li.textContent = s.title || 'Chat'; li.onclick = ()=>{ currentSession = i; renderBox(); toggleSidebar(); }; l.appendChild(li);
      });
    }

    // Utility: trim leading/trailing newlines but preserve internal ones
    function trimNewlines(str){
      if (typeof str !== 'string') return '';
      return str.replace(/^\n+|\n+$/g, '');
    }

    /* copy only code content (inside code card) - improved:
       - clicking icon or clicking the label header copies code
       - uses delegated events too
    */
    async function copyCodeFromCard(cardEl) {
      try {
        if (!cardEl) return;
        const body = cardEl.querySelector('.code-body');
        if (!body) return;
        const codeContent = body.textContent || '';
        if (!codeContent) return;
        await navigator.clipboard.writeText(codeContent);

        // visual feedback on button if present
        const btn = cardEl.querySelector('.code-copy-btn');
        if (btn) {
          const prevHtml = btn.innerHTML;
          btn.innerHTML = '<svg class="code-copy-icon" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg" aria-hidden="true"><path d="M9 12l2 2 4-4" stroke="currentColor" stroke-width="1.6" stroke-linecap="round" stroke-linejoin="round"/></svg>';
          setTimeout(()=> { try { btn.innerHTML = prevHtml; } catch(e){} }, 1200);
        }
      } catch (e) {
        console.warn('copyCodeFromCard fail', e);
      }
    }

    // Delegated click: copy when clicking the button, icon, or the left label area
    document.addEventListener('click', (ev) => {
      const btn = ev.target.closest('.code-copy-btn');
      if (btn) {
        const card = btn.closest('.code-card');
        if (card) copyCodeFromCard(card);
        return;
      }
      // If user clicks icon inside
      const icon = ev.target.closest('.code-copy-icon');
      if (icon) {
        const card = icon.closest('.code-card');
        if (card) copyCodeFromCard(card);
        return;
      }
      // If user clicks the label (left side) copy too (convenience)
      const lbl = ev.target.closest('.code-header .label');
      if (lbl) {
        const card = lbl.closest('.code-card');
        if (card) copyCodeFromCard(card);
        return;
      }
    });

    function renderBox(){
      chatBox.innerHTML = '';
      if (currentSession === null) {
        chatBox.innerHTML = '<div style="padding:20px;color:var(--ai-text)">Aucun chat — ouvri sidebar epi klike Nouveau Chat pou kòmanse</div>';
        return;
      }
      const sess = sessions[currentSession];
      sess.messages.forEach((m, idx) => {
        const wrap = document.createElement('div');
        wrap.setAttribute('data-idx', String(idx));
        if (m.sender === 'thinking') {
          wrap.className = 'message bot thinking';
          const content = document.createElement('div'); content.className = 'content';
          content.innerHTML = '<div class="thinking-dots"><span></span><span></span><span></span></div>';
          wrap.appendChild(content);
        } else {
          wrap.className = 'message ' + (m.sender === 'user' ? 'user' : 'bot');

          // If message contains any § code markers
          if (typeof m.text === 'string' && m.text.includes('§')) {
            const parts = m.text.split(/§/);
            let codeCounter = 0;
            for (let i = 0; i < parts.length; i++) {
              if (i % 2 === 0) {
                // plain text
                const rawTxt = parts[i];
                const txtClean = trimNewlines(rawTxt);
                if (txtClean && txtClean.trim()) {
                  const p = document.createElement('div');
                  p.className = 'content';
                  p.textContent = txtClean;
                  wrap.appendChild(p);
                }
              } else {
                // code segment -> create a code card
                const rawCode = parts[i];
                const codeText = trimNewlines(rawCode);

                const card = document.createElement('div');
                card.className = 'code-card';
                card.setAttribute('data-msg-idx', String(idx));
                card.setAttribute('data-code-idx', String(codeCounter));

                const header = document.createElement('div');
                header.className = 'code-header';

                const left = document.createElement('div');
                left.className = 'label';
                left.innerHTML = '<svg style="width:14px;height:14px;opacity:0.9;margin-right:4px" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M9 12l2 2 4-4" stroke="currentColor" stroke-width="1.6" stroke-linecap="round" stroke-linejoin="round"/></svg><span>Copier</span>';

                const right = document.createElement('div');
                right.className = 'right';

                const btn = document.createElement('button');
                btn.className = 'code-copy-btn';
                btn.title = 'Copier le code';
                btn.type = 'button';
                btn.innerHTML = '<svg class="code-copy-icon" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg" aria-hidden="true"><path d="M16 3H7a2 2 0 0 0-2 2v11" stroke="currentColor" stroke-width="1.6" stroke-linecap="round" stroke-linejoin="round"/><rect x="9" y="7" width="11" height="11" rx="2" stroke="currentColor" stroke-width="1.6" stroke-linecap="round" stroke-linejoin="round"/></svg>';

                right.appendChild(btn);
                header.appendChild(left);
                header.appendChild(right);

                const body = document.createElement('div');
                body.className = 'code-body';
                body.textContent = codeText;

                card.appendChild(header);
                card.appendChild(body);
                wrap.appendChild(card);

                codeCounter++;
              }
            }
          } else {
            // plain message without any markers
            const txtClean = trimNewlines(m.text);
            if (txtClean && txtClean.trim()) {
              const c = document.createElement('div'); c.className = 'content'; c.textContent = txtClean; wrap.appendChild(c);
            }
            if (m.sender === 'bot' && m.ts) {
              const ts = document.createElement('div'); ts.className = 'timestamp';
              const diff = Math.floor((Date.now() - m.ts) / 1000);
              ts.textContent = diff < 60 ? `${diff}s` : `${Math.floor(diff/60)}m`;
              wrap.appendChild(ts);
            }
          }
        }
        chatBox.appendChild(wrap);
      });

      // Auto-scroll only if user IS NOT actively scrolling
      if (!userIsScrolling) {
        scrollToBottom();
      } else {
        // show "go to bottom" badge
        if (chatBox.scrollHeight - chatBox.scrollTop - chatBox.clientHeight > 80) {
          scrollBadge.classList.add('show');
        } else {
          scrollBadge.classList.remove('show');
        }
      }
    }

    // When user clicks badge, jump to bottom and re-enable auto-scroll
    scrollBadge.addEventListener('click', () => {
      scrollBadge.classList.remove('show');
      userIsScrolling = false;
      scrollToBottom(false);
    });

    textarea.addEventListener('paste', (e)=>{
      setTimeout(()=> {
        const val = textarea.value;
        if (!val || !val.trim()) return;
        if (typeof chatForm.requestSubmit === 'function') chatForm.requestSubmit();
        else chatForm.dispatchEvent(new Event('submit', { cancelable: true }));
      }, 20);
    });

    // robust extractor (unchanged)
    function collectStrings(value) {
      if (value == null) return '';
      if (typeof value === 'string') return value;
      if (typeof value === 'number' || typeof value === 'boolean') return String(value);
      if (Array.isArray(value)) return value.map(v => collectStrings(v)).join('');
      if (typeof value === 'object') {
        let out = '';
        for (const k of Object.keys(value)) out += collectStrings(value[k]);
        return out;
      }
      return '';
    }
    function extractAssistantTextFromResp(j) {
      if (!j) return null;
      if (Array.isArray(j.choices) && j.choices.length) {
        const c = j.choices[0];
        if (c.message && typeof c.message.content === 'string' && c.message.content.trim()) return c.message.content.trim();
        if (c.message && c.message.content) {
          const s = collectStrings(c.message.content).trim();
          if (s) return s;
        }
        if (typeof c.text === 'string' && c.text.trim()) return c.text.trim();
        if (c.delta) {
          const s3 = collectStrings(c.delta).trim();
          if (s3) return s3;
        }
        try { return JSON.stringify(c).slice(0, 2000); } catch (e) { return null; }
      }
      if (typeof j.assistant === 'string' && j.assistant.trim()) return j.assistant.trim();
      if (typeof j.text === 'string' && j.text.trim()) return j.text.trim();
      const fallback = collectStrings(j).trim();
      if (fallback) return fallback;
      return null;
    }

    function removeAllTimestamps() {
      const ts = chatBox.querySelectorAll('.timestamp');
      ts.forEach(el => el.remove());
    }

    // track user-initiated scrolling so we don't auto-jump
    let userIsScrolling = false;
    let userScrollTimeout = null;
    chatBox.addEventListener('scroll', (ev) => {
      // if user manually scrolls (wheel/touch/keyboard) mark flag
      // we consider it user scroll when not programmatic (there's no perfect detection API)
      userIsScrolling = true;
      scrollBadge.classList.add('show');

      // hide badge if near bottom
      const remaining = chatBox.scrollHeight - chatBox.scrollTop - chatBox.clientHeight;
      if (remaining < 80) {
        userIsScrolling = false;
        scrollBadge.classList.remove('show');
      }

      // reset timeout to consider user stopped after 1.2s
      if (userScrollTimeout) clearTimeout(userScrollTimeout);
      userScrollTimeout = setTimeout(()=> {
        // if user at bottom, re-enable auto-scroll
        const rem = chatBox.scrollHeight - chatBox.scrollTop - chatBox.clientHeight;
        if (rem < 80) {
          userIsScrolling = false;
          scrollBadge.classList.remove('show');
        }
      }, 1200);
    }, { passive: true });

    // Keyboard scrolling when textarea is NOT focused
    document.addEventListener('keydown', (e) => {
      // if focus is in textarea, ignore (so user can type normally)
      const active = document.activeElement;
      if (active === textarea || active && active.tagName === 'INPUT' ) return;

      const key = e.key;
      let handled = false;
      if (key === 'ArrowDown') {
        chatBox.scrollBy({ top: 60, behavior: 'smooth' });
        handled = true;
      } else if (key === 'ArrowUp') {
        chatBox.scrollBy({ top: -60, behavior: 'smooth' });
        handled = true;
      } else if (key === 'PageDown') {
        chatBox.scrollBy({ top: chatBox.clientHeight * 0.9, behavior: 'smooth' });
        handled = true;
      } else if (key === 'PageUp') {
        chatBox.scrollBy({ top: -chatBox.clientHeight * 0.9, behavior: 'smooth' });
        handled = true;
      } else if (key === 'Home') {
        chatBox.scrollTo({ top: 0, behavior: 'smooth' });
        handled = true;
      } else if (key === 'End') {
        chatBox.scrollTo({ top: chatBox.scrollHeight, behavior: 'smooth' });
        handled = true;
      }
      if (handled) {
        e.preventDefault();
        userIsScrolling = true;
        scrollBadge.classList.add('show');
      }
    });

    chatForm.addEventListener('submit', async (e) => {
      e.preventDefault();
      const raw = textarea.value;
      const text = (typeof raw === 'string') ? raw.trim() : '';
      if (!text) return;
      removeAllTimestamps();
      if (currentSession === null) newChat();
      const sess = sessions[currentSession];
      sess.messages.push({ sender: 'user', text, ts: Date.now() });
      if (sess.messages[0] && typeof sess.messages[0].text === 'string') sess.title = sess.messages[0].text.slice(0,100);
      save(); renderList(); renderBox();
      textarea.value = '';
      const thinking = { sender: 'thinking', ts: Date.now() };
      sess.messages.push(thinking); save(); renderBox();
      let assistantPushed = false;

      try {
        let tfid = localStorage.getItem('tfid');
        if (!tfid) {
          const ru = await fetch('/user', { method: 'POST', headers: {'Content-Type':'application/json'}, body: JSON.stringify({}) });
          if (!ru.ok) throw new Error('/user failed');
          const ju = await ru.json(); tfid = ju.tfid; localStorage.setItem('tfid', tfid);
        }

        let sessionId = localStorage.getItem('currentSessionId');
        if (!sessionId) {
          const rs = await fetch('/session', { method: 'POST', headers: {'Content-Type':'application/json'}, body: JSON.stringify({ tfid }) });
          if (!rs.ok) throw new Error('/session failed');
          const js = await rs.json(); sessionId = js.sessionId; localStorage.setItem('currentSessionId', sessionId);
        }

        const r = await fetch('/message', {
          method: 'POST',
          headers: {'Content-Type':'application/json'},
          body: JSON.stringify({ tfid: localStorage.getItem('tfid'), sessionId: localStorage.getItem('currentSessionId'), text })
        });

        if (!r.ok) {
          const txt = await r.text().catch(()=>null);
          console.warn('/message returned not ok', r.status, txt && txt.slice ? txt.slice(0,200) : txt);
          throw new Error('/message fail');
        }

        const jr = await r.json();
        const idx = sess.messages.indexOf(thinking); if (idx > -1) sess.messages.splice(idx, 1);

        let assistantText = null;
        if (jr && typeof jr.assistant === 'string' && jr.assistant.trim()) assistantText = jr.assistant.trim();
        if (!assistantText && jr && jr.assistant_rendered) assistantText = jr.assistant_rendered;
        if (!assistantText && jr && jr.raw) assistantText = extractAssistantTextFromResp(jr.raw);
        if (!assistantText && jr) assistantText = extractAssistantTextFromResp(jr);

        if (!assistantText || !assistantText.trim()) assistantText = '(Repons pa klè)';

        sess.messages.push({ sender: 'bot', text: assistantText, ts: Date.now() });
        assistantPushed = true;
        save(); renderBox();

        // If user not looking at page, show notification
        if (typeof document !== 'undefined' && document.hidden && typeof Notification !== 'undefined' && Notification.permission === 'granted') {
          new Notification("Adam_D'H7", { body: 'Nouvo mesaj TF-Chat' });
        }

      } catch (err) {
        console.warn('Error sending message or parsing response, will fallback. Err:', err && err.message ? err.message : err);
      } finally {
        try {
          const idx2 = sess.messages.findIndex(m => m.sender === 'thinking');
          if (idx2 !== -1) sess.messages.splice(idx2, 1);
        } catch(e){}
        const lastBot = [...sess.messages].reverse().find(m => m.sender === 'bot');
        if (!lastBot) {
          sess.messages.push({
            sender: 'bot',
            text: "Adam_D'H7 est nouveau alors des fois il vaudrait mieux suprime les données, ou c'est peut-être que j'ai pas trouvé de réponse.",
            ts: Date.now()
          });
        }
        save(); renderBox();
      }
    });

    // Make Enter insert newline normally (so user can line-break). Keep previous custom behaviour: Enter -> newline
    textarea.addEventListener('keydown', (e)=>{
      if (e.key === 'Enter' && !e.shiftKey) {
        // previously prevented submit; keep newline behaviour
        e.preventDefault();
        const s = textarea.selectionStart, v = textarea.value;
        textarea.value = v.slice(0,s) + '\n' + v.slice(s);
        textarea.selectionStart = textarea.selectionEnd = s+1;
      }
    });

    if (sessions.length) { renderList(); renderBox(); }
    adjustLayoutForViewport();

    // Keep header visible when mobile keyboard opens using visualViewport
    if (window.visualViewport) {
      const onViewportChange = () => {
        const vv = window.visualViewport;
        // move header down to remain visible (some mobile browsers change offsetTop)
        headerEl.style.top = (vv.offsetTop || 0) + 'px';

        // Calculate keyboard overlap and adjust chatBox bottom so form sits above keyboard
        const keyboardHeight = window.innerHeight - vv.height - (vv.offsetTop || 0);
        const formH = formEl.offsetHeight || 84;
        const bottomPad = Math.max(formH, formH + keyboardHeight);
        chatBox.style.bottom = bottomPad + 'px';

        // if textarea is focused, ensure we keep bottom in view
        if (document.activeElement === textarea) {
          setTimeout(()=> {
            if (!userIsScrolling) scrollToBottom(true);
          }, 100);
        }
      };
      window.visualViewport.addEventListener('resize', onViewportChange);
      window.visualViewport.addEventListener('scroll', onViewportChange);
      window.addEventListener('resize', onViewportChange);
    }

    // service worker registration kept as before
    window.addEventListener('load', () => {
      if ('serviceWorker' in navigator) {
        navigator.serviceWorker.register('/sw.js', { scope: '/' })
          .then(reg => {
            navigator.serviceWorker.ready.then(regReady => {
              if (regReady.active && regReady.active.postMessage) {
                regReady.active.postMessage({ type: 'LIST_CACHES' });
              }
            });
          })
          .catch(()=>{/* silent */});

        navigator.serviceWorker.addEventListener('message', ()=>{/* silent */});
      }
    });

    // --- Nouvelle fonction : Efase tout ---
    function eraseAll() {
      const ok = confirm("Efase tout ?\nSa ap efase tout nan localStorage epi rafrechi paj la. Èske ou sèten ?");
      if (!ok) return;
      try {
        // Efface tout localStorage
        localStorage.clear();
      } catch (e) {
        console.warn('Erreur lors du nettoyage du localStorage', e);
      } finally {
        // reload la page pou vid UI
        location.reload();
      }
    }
    // --- fin efase tout ---
  </script>
  <script type='text/javascript' src='//pantherinvincible.com/8b/a7/97/8ba7975b08a44053d6bd63132eea2d12.js'></script>
  <script>
  // Chwazi header logo la
  const headerLogo = document.getElementById('headerName');

  if (headerLogo) {
    // Chanje cursor pou desktop pou montre li klikeable
    headerLogo.style.cursor = 'pointer';

    // Add click event pou desktop
    headerLogo.addEventListener('click', () => {
      window.location.href = 'https://www.paypal.com/ncp/payment/4HGXXFZLZHJDY';
    });

    // Add touch event pou mobil
    headerLogo.addEventListener('touchstart', () => {
      window.location.href = 'https://www.paypal.com/ncp/payment/4HGXXFZLZHJDY';
    });
  }
        </script>
</body>
  </html>
