<!DOCTYPE html>
<html lang="ht">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,viewport-fit=cover"/>
  <title>Adam_D'H7 — Assistant multimédia</title>
  <style>
    :root{
      --bg:#000;
      --panel:#000;
      --ai-bubble:#262626;
      --ai-text:#d0d0d0;
      --user-blue:#0b3d91;
      --user-text:#e8f4ff;
      --muted:#7d7d7d;
      --header-h:56px;
      --form-h:96px;
      --msg-gap:8px;
      --max-msg-w:76%;
    }
    html,body{height:100%;margin:0;background:var(--bg);color:var(--ai-text);font-family:Inter,Roboto,Arial,sans-serif;-webkit-text-size-adjust:100%}
    header{height:var(--header-h);position:fixed;left:0;right:0;top:0;display:flex;align-items:center;justify-content:center;z-index:60;background:var(--panel);box-shadow:0 1px 0 rgba(255,255,255,0.02) inset}
    .title{font-weight:800;color:var(--muted);font-size:18px}
    .chat-box{position:fixed;top:var(--header-h);bottom:calc(var(--form-h));left:0;right:0;padding:12px;overflow:auto;-webkit-overflow-scrolling:touch;box-sizing:border-box;display:flex;flex-direction:column;gap:var(--msg-gap)}
    .chat-box::-webkit-scrollbar{display:none}
    .message{max-width:var(--max-msg-w);word-break:break-word;white-space:pre-wrap;padding:0;display:block}
    .message.user{align-self:flex-end}
    .message.bot{align-self:flex-start}
    .bubble{padding:10px 14px;border-radius:14px;display:inline-block;font-size:15px;line-height:1.35}
    .bubble.user{background:var(--user-blue);color:var(--user-text)}
    .bubble.bot{background:var(--ai-bubble);color:var(--ai-text);border:1px solid rgba(255,255,255,0.03)}
    .meta{font-size:11px;color:var(--muted);margin-top:6px;text-align:right}
    .message-images { display:flex; gap:8px; margin-top:6px; flex-wrap:wrap; align-items:flex-start; }
    .message-images .img-small { width:96px; height:96px; border-radius:10px; object-fit:cover; cursor:pointer; border:1px solid rgba(255,255,255,0.04); }
    .message-images .img-large { width:100%; max-width:920px; height:auto; border-radius:12px; object-fit:contain; cursor:pointer; box-shadow:0 8px 30px rgba(0,0,0,0.6); border:1px solid rgba(255,255,255,0.03); }
    @media (max-width:920px){ .message-images .img-large { max-width:90vw; } .message{max-width:90%;} }
    @media (max-width:520px){ :root{--max-msg-w:86%} .title{font-size:16px} .message-images .img-small{width:72px;height:72px} }
    .bottom-zone{position:fixed;left:0;right:0;bottom:0;padding:10px 12px;box-sizing:border-box;background:linear-gradient(180deg,transparent,rgba(0,0,0,0.02));display:flex;flex-direction:column;gap:8px;z-index:50}
    .progress-row{display:flex;align-items:center;gap:8px;height:18px}
    .progress-bar{flex:1;height:6px;background:rgba(255,255,255,0.06);border-radius:6px;overflow:hidden}
    .progress-fill{height:100%;width:0%;background:linear-gradient(90deg,#ff6b6b,#ff3b3b);transition:width 120ms linear}
    .progress-label{font-size:12px;color:var(--muted);min-width:44px;text-align:left}
    form{display:flex;align-items:center;gap:10px;padding:8px 0}
    .input-wrap{flex:1;display:flex;flex-direction:column;gap:6px}
    textarea{flex:1;min-height:56px;max-height:160px;padding:12px;border-radius:14px;background:#050505;border:1px solid rgba(255,255,255,0.04);color:var(--ai-text);resize:none;outline:none;font-size:15px;box-sizing:border-box}
    textarea::placeholder{color:rgba(255,255,255,0.16)}
    .send{width:56px;height:56px;border-radius:50%;border:none;display:flex;align-items:center;justify-content:center;background:linear-gradient(180deg,var(--user-blue),#06306a);cursor:pointer;box-shadow:0 8px 20px rgba(11,61,145,0.12)}
    .send svg{width:22px;height:22px;fill:#fff}
    .send.recording{background:linear-gradient(180deg,#9b1b1b,#7a1515)}
    .softbreak{word-break:break-word;white-space:pre-wrap}
    #modal{position:fixed;left:0;top:0;right:0;bottom:0;background:rgba(0,0,0,0.92);display:none;align-items:center;justify-content:center;z-index:100}
    #modal .controls{position:absolute;top:14px;right:14px;display:flex;gap:8px}
    #modal button{background:transparent;border:1px solid rgba(255,255,255,0.06);padding:8px;border-radius:8px;color:var(--ai-text);cursor:pointer}
    #modalImg{max-width:92%;max-height:86%;border-radius:8px;object-fit:contain}
    .typing-dots { font-weight:800; letter-spacing:3px; display:inline-block; min-width:48px; text-align:left; }
  </style>
</head>
<body>
  <header>
    <div class="title">Adam_D'H7</div>
  </header>

  <main id="chatBox" class="chat-box" aria-live="polite"></main>

  <div class="bottom-zone" aria-hidden="false">
    <div id="progressRow" class="progress-row" style="display:none">
      <div id="progressLabel" class="progress-label">0s</div>
      <div class="progress-bar" aria-hidden="true">
        <div id="progressFill" class="progress-fill" style="width:0%"></div>
      </div>
      <div style="width:36px;text-align:right;color:var(--muted);font-size:12px" id="progressLimit">60s</div>
    </div>

    <form id="chatForm" autocomplete="off" novalidate style="display:flex;align-items:flex-end;gap:10px">
      <div class="input-wrap" style="flex:1">
        <textarea id="userInput" placeholder="Ekris... oswa peze bouton vwa pou anrejistre" aria-label="Message"></textarea>
      </div>

      <button id="sendBtn" class="send" type="button" aria-label="Send">
        <svg id="sendIcon" viewBox="0 0 24 24" aria-hidden="true"><path d="M12 3c-.6 0-1 .4-1 1v8h-8c-.6 0-1 .4-1 1 0 .3.1.6.3.8l12 10c.4.3 1 .3 1.4 0l8-6c.4-.3.6-.8.5-1.3s-.4-.8-.9-.9L12 3z" fill="#fff"/></svg>
      </button>
    </form>
  </div>

  <div id="modal" style="display:none;align-items:center;justify-content:center;">
    <div class="controls">
      <button id="downloadImgBtn">Download</button>
      <button id="closeModalBtn">✖</button>
    </div>
    <img id="modalImg" src="" alt="Preview"/>
  </div>

<script>
(() => {
  // ---- CONFIG ----
  const API = 'https://adamdh7.adamdh7.workers.dev/';
  const TF_KEY = 'tfid_v1';
  const MAX_TEXT = 7777777;

  // ---- UI refs ----
  const chatBox = document.getElementById('chatBox');
  const userInput = document.getElementById('userInput');
  const sendBtn = document.getElementById('sendBtn');
  const sendIcon = document.getElementById('sendIcon');
  const progressRow = document.getElementById('progressRow');
  const progressFill = document.getElementById('progressFill');
  const progressLabel = document.getElementById('progressLabel');
  const modal = document.getElementById('modal');
  const modalImg = document.getElementById('modalImg');
  const downloadImgBtn = document.getElementById('downloadImgBtn');
  const closeModalBtn = document.getElementById('closeModalBtn');

  // ---- state ----
  let TFID = null;
  let recorder = null;
  let recordedChunks = [];
  let recording = false;
  let recordStart = 0;
  let recordTimer = null;
  let maxRecordSec = 60;

  // ---- helpers ----
  function softBreak(s, n=40){ if(!s) return ''; return s.replace(new RegExp(`([^\\s]{${n}})`, 'g'), '$1<wbr>'); }
  function escapeHtml(s){ if(!s) return ''; return String(s).replace(/&/g,'&amp;').replace(/</g,'&lt;').replace(/>/g,'&gt;'); }
  function fetchWithTimeout(url, options={}, timeout=420000){ const controller = new AbortController(); options.signal = controller.signal; const timer = setTimeout(()=> controller.abort(), timeout); return fetch(url, options).then(res => { clearTimeout(timer); return res; }).catch(err => { clearTimeout(timer); throw err; }); }

  // ---- rendering (NO localStorage of messages) ----
  function clearMessages(){ chatBox.innerHTML = ''; }
  function renderMessage({who='bot', text=null, images=null, audioUrl=null, ts=Date.now()}) {
    const msg = document.createElement('div');
    msg.className = 'message ' + (who === 'user' ? 'user' : 'bot');
    if(text){
      const b = document.createElement('div');
      b.className = 'bubble ' + (who === 'user' ? 'user' : 'bot');
      b.innerHTML = softBreak(escapeHtml(text), 40);
      msg.appendChild(b);
    }
    if(Array.isArray(images) && images.length){
      const container = document.createElement('div'); container.className = 'message-images';
      if(images.length === 1){
        const im = document.createElement('img'); im.className='img-large'; im.src = images[0]; im.alt='generated image'; im.loading='lazy';
        im.addEventListener('click', ()=> openModal(images[0])); container.appendChild(im);
      } else {
        images.forEach(src => { const im = document.createElement('img'); im.className='img-small'; im.src = src; im.alt='generated image'; im.loading='lazy'; im.addEventListener('click', ()=> openModal(src)); container.appendChild(im); });
      }
      msg.appendChild(container);
    }
    if(audioUrl){
      const ap = document.createElement('div'); ap.className='audio-player'; ap.style.marginTop='6px';
      const a = document.createElement('audio'); a.controls=true; a.src = audioUrl; a.style.maxWidth='220px'; ap.appendChild(a); msg.appendChild(ap);
    }
    const meta = document.createElement('div'); meta.className='meta'; meta.textContent = new Date(ts).toLocaleTimeString();
    msg.appendChild(meta);
    chatBox.appendChild(msg);
    setTimeout(()=> chatBox.scrollTop = chatBox.scrollHeight, 80);
  }

  function renderSessionMessages(messages){
    // messages expected as array from backend session (ordered)
    clearMessages();
    if(!Array.isArray(messages)) return;
    for(const m of messages){
      const who = (m.from === 'user') ? 'user' : 'bot';
      let text = null; let images = null; let audioUrl = null;
      if(m.type === 'text') text = m.text || null;
      else if(m.type === 'image'){
        if(m.url && typeof m.url === 'string') images = [m.url];
        else if(Array.isArray(m.url)) images = m.url.slice();
        else if(m.meta && m.meta.prompt) text = m.meta.prompt;
      } else if(m.type === 'audio'){
        audioUrl = (m.url && typeof m.url === 'string') ? m.url : null;
        text = m.transcription || null;
      } else {
        text = m.text || m.transcription || null;
      }
      renderMessage({ who, text, images, audioUrl, ts: m.ts || Date.now() });
    }
  }

  function createTypingController(){
    const id = 'typing_' + Date.now();
    const el = document.createElement('div'); el.className = 'message bot'; const b = document.createElement('div'); b.className='bubble bot';
    const dotsSpan = document.createElement('span'); dotsSpan.className='typing-dots'; dotsSpan.textContent='●'; b.appendChild(dotsSpan); el.appendChild(b);
    const meta = document.createElement('div'); meta.className='meta'; meta.textContent=''; el.appendChild(meta);
    chatBox.appendChild(el); chatBox.scrollTop = chatBox.scrollHeight;
    let state=1; let running=true;
    const interval = setInterval(()=>{ if(!running) return; state = state>=3?1:state+1; dotsSpan.textContent='●'.repeat(state); },500);
    return { el, stop: ()=> { running=false; clearInterval(interval); try{ el.remove(); }catch(e){} } };
  }

  function openModal(src){ modalImg.src = src; modal.style.display = 'flex'; downloadImgBtn.onclick = ()=> { const a = document.createElement('a'); a.href = src; a.download = 'image.png'; document.body.appendChild(a); a.click(); a.remove(); }; }
  function closeModal(){ modal.style.display = 'none'; modalImg.src = ''; }
  closeModalBtn.addEventListener('click', closeModal);
  modal.addEventListener('click', (e)=>{ if(e.target === modal) closeModal(); });

  // ---- TFID helpers (only TFID persisted) ----
  async function genTfCandidate(len){
    let s=''; const chars='0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ';
    const arr = new Uint32Array(len); crypto.getRandomValues(arr);
    for(let i=0;i<len;i++) s += chars[arr[i] % chars.length];
    return 'TF-' + s;
  }
  async function registerTfid(candidate){
    try{
      const res = await fetch(API + 'session/create', { method:'POST', headers:{'Content-Type':'application/json'}, body: JSON.stringify({ tfid: candidate }) });
      const j = await res.json().catch(()=>null);
      if(j && j.ok) return j.tfid || candidate;
      return false;
    }catch(e){ return false; }
  }
  async function getOrCreateTfid(){
    let tf = localStorage.getItem(TF_KEY);
    if(tf) return tf;
    let len = 7;
    for(let round=0;round<6;round++){
      for(let i=0;i<6;i++){
        const cand = await genTfCandidate(len);
        const ok = await registerTfid(cand);
        if(ok){ localStorage.setItem(TF_KEY, cand); return cand; }
      }
      len++;
    }
    const fb = 'TF-' + Date.now();
    await registerTfid(fb);
    localStorage.setItem(TF_KEY, fb);
    return fb;
  }

  // ---- session sync ----
  async function fetchSessionAndRender(tfid, retries=2){
    if(!tfid) return;
    try{
      const res = await fetchWithTimeout(API + 'session?tfid=' + encodeURIComponent(tfid), {}, 15000);
      if(!res.ok) return;
      const j = await res.json().catch(()=>null);
      if(j && j.ok && j.session && Array.isArray(j.session.messages)){
        renderSessionMessages(j.session.messages);
      }
    }catch(e){
      if(retries>0) setTimeout(()=> fetchSessionAndRender(tfid, retries-1), 800);
    }
  }

  // ---- chat send / receive ----
  async function callChat(text){
    if(!TFID) TFID = await getOrCreateTfid();
    if(!text || !text.trim()) return;
    if(text.length > MAX_TEXT){ renderMessage({who:'bot', text:'Tèks twò long. Limit ' + MAX_TEXT + ' karaktè.'}); return; }

    // optimistic: show user bubble immediately (but not saved locally)
    renderMessage({ who:'user', text, ts: Date.now() });

    const typing = createTypingController();
    try{
      const res = await fetchWithTimeout(API, { method:'POST', headers:{'Content-Type':'application/json'}, body: JSON.stringify({ action:'chat', text, tfid: TFID }) }, 420000);
      let j = null;
      try{ j = await res.clone().json(); }catch(e){ j = null; }
      // If backend returned updated session, render it (server is source of truth)
      if(j && j.ok && j.session && Array.isArray(j.session.messages)){
        typing.stop();
        renderSessionMessages(j.session.messages);
        return;
      }
      // fallback: if resp text present
      if(j && j.ok && (j.text || j.post_text || j.imageUrl)){
        typing.stop();
        if(j.imageUrl){
          // If imageUrl returned plus optional text, we re-fetch session to get canonical messages
          await fetchSessionAndRender(TFID);
          return;
        }
        if(j.text || j.post_text){
          renderMessage({ who:'bot', text: (j.text || j.post_text), ts: Date.now() });
          // then sync full session
          await fetchSessionAndRender(TFID);
          return;
        }
      }

      // if not JSON, try plain text
      try{
        const txt = await res.clone().text();
        if(txt && txt.trim()){
          typing.stop();
          renderMessage({ who:'bot', text: txt.trim(), ts: Date.now() });
          await fetchSessionAndRender(TFID);
          return;
        }
      }catch(e){}

      // nothing useful: show not found message
      typing.stop();
      renderMessage({ who:'bot', text: '(Pa jwenn repons)', ts: Date.now() });
      // try to sync session anyway
      await fetchSessionAndRender(TFID);
    }catch(err){
      typing.stop();
      renderMessage({ who:'bot', text: '(Pa jwenn repons)', ts: Date.now() });
      // attempt re-sync
      setTimeout(()=> fetchSessionAndRender(TFID), 1000);
    }
  }

  // ---- audio recording / transcription ----
  function startRecordTimer(){
    recordTimer = setInterval(()=>{ const s = Math.floor((Date.now()-recordStart)/1000); progressLabel.textContent = s + 's'; const pct = Math.min(100, (s/maxRecordSec)*100); progressFill.style.width = pct + '%'; if(s>=maxRecordSec) stopRecording(); }, 200);
  }
  function stopRecordTimer(){ clearInterval(recordTimer); progressFill.style.width='0%'; progressLabel.textContent='0s'; }

  async function startRecording(){
    if(userInput.value.trim()) return;
    if(!navigator.mediaDevices || !navigator.mediaDevices.getUserMedia){ alert('Mikwofòn pa disponib sou navigatè sa a.'); return; }
    try{
      const stream = await navigator.mediaDevices.getUserMedia({ audio:true });
      recordedChunks = [];
      recorder = new MediaRecorder(stream);
      recorder.ondataavailable = e => { if(e.data && e.data.size) recordedChunks.push(e.data); };
      recorder.onstop = async () => {
        const blob = new Blob(recordedChunks, { type:'audio/webm' });
        const url = URL.createObjectURL(blob);
        // show user audio bubble (optimistic)
        renderMessage({ who:'user', text: null, audioUrl: url, ts: Date.now() });
        // send to transcription endpoint
        await sendBlobForTranscription(blob);
        stream.getTracks().forEach(t=>t.stop());
      };
      recorder.start();
      recording = true; recordStart = Date.now();
      progressRow.style.display = 'flex'; progressFill.style.width='0%'; progressLabel.textContent='0s'; startRecordTimer(); updateSendIcon();
    }catch(err){
      alert('Pa jwenn aksè mikwofòn: ' + (err && err.message ? err.message : err));
    }
  }
  function stopRecording(){ if(recorder && recorder.state !== 'inactive') recorder.stop(); recording = false; stopRecordTimer(); progressRow.style.display = 'none'; updateSendIcon(); }

  async function sendBlobForTranscription(blob){
    if(!TFID) TFID = await getOrCreateTfid();
    try{
      const fd = new FormData(); fd.append('file', blob, 'voice.webm'); fd.append('action','transcribe'); fd.append('tfid', TFID);
      const res = await fetchWithTimeout(API, { method:'POST', body: fd }, 420000);
      let j = null;
      try{ j = await res.clone().json(); }catch(e){ j = null; }
      if(!j){
        try{ const txt = await res.clone().text(); if(txt && txt.trim()) j = { text: txt.trim() }; }catch(e){}
      }
      const text = (j && (j.text || (j.aiRaw && j.aiRaw.text))) ? (j.text || j.aiRaw.text) : null;
      if(text){
        // show user text and call chat (will re-sync session after)
        renderMessage({ who:'user', text, ts: Date.now() });
        await callChat(text);
      } else {
        renderMessage({ who:'bot', text: 'Transcription pa jwenn tèks.', ts: Date.now() });
        await fetchSessionAndRender(TFID);
      }
    }catch(e){
      renderMessage({ who:'bot', text: 'Erè pandan transcription: ' + (e && e.message ? e.message : e), ts: Date.now() });
      setTimeout(()=> fetchSessionAndRender(TFID), 1000);
    }
  }

  // ---- UI events ----
  function updateSendIcon(){
    const txt = (userInput.value || '').trim();
    if(recording){ sendBtn.classList.add('recording'); sendIcon.innerHTML = '<path d="M6 6h12v12H6z" fill="#fff"/>'; }
    else if(txt){ sendBtn.classList.remove('recording'); sendIcon.innerHTML = '<path d="M2 21L23 12L2 3L8 12L2 21Z" fill="#fff"/>'; }
    else { sendBtn.classList.remove('recording'); sendIcon.innerHTML = '<path d="M12 14a3 3 0 0 0 3-3V5a3 3 0 0 0-6 0v6a3 3 0 0 0 3 3zm5-3a5 5 0 0 1-10 0H5a7 7 0 0 0 14 0h-2z"/>'; }
  }
  userInput.addEventListener('input', updateSendIcon);

  sendBtn.addEventListener('click', async ()=>{
    const text = (userInput.value || '').trim();
    if(recording){ stopRecording(); return; }
    if(text){ userInput.value=''; updateSendIcon(); await callChat(text); } else { await startRecording(); }
  });

  userInput.addEventListener('keydown', (e)=>{ if(e.key === 'Enter' && !e.shiftKey && (e.ctrlKey || e.metaKey)){ e.preventDefault(); sendBtn.click(); } });

  // ---- startup: ensure TFID only, then sync session from server ----
  (async ()=>{
    TFID = await getOrCreateTfid();
    // fetch server-side session and render (server is source of truth)
    await fetchSessionAndRender(TFID);
    updateSendIcon();
  })();

  // visual-viewport handler (keep same behaviour)
  if(window.visualViewport){
    const onView = () => {
      const vv = window.visualViewport;
      const header = document.querySelector('header');
      header.style.top = (vv.offsetTop || 0) + 'px';
      const kbHeight = window.innerHeight - vv.height - (vv.offsetTop || 0);
      const bottomZone = document.querySelector('.bottom-zone');
      const formH = bottomZone.offsetHeight || 140;
      const bottomPad = Math.max(formH, formH + kbHeight);
      document.querySelector('.chat-box').style.bottom = bottomPad + 'px';
      if(document.activeElement === userInput) setTimeout(()=> chatBox.scrollTop = chatBox.scrollHeight, 100);
    };
    window.visualViewport.addEventListener('resize', onView);
    window.visualViewport.addEventListener('scroll', onView);
    window.addEventListener('resize', onView);
  }

  window.toggleSidebar = ()=> { };

})();
</script>
</body>
</html>
